package tes.semarang.satelite;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.atomic.AtomicInteger;

import example.exercism.ConstructBinaryTree.Node;

public class Satellite {
	int preIndex = 0;
	
	public Satellite() {
	}
	
	public Tree treeFromTraversals(List<Character> preorder, List<Character> inorder) {
		int len = inorder.size();
		if (0 > len-1)
			return null;

		Node tNode = new Node(preorder.get(preIndex++));

		if (0 == len-1)
			return tNode;

		int inIndex = search(in, inStrt, inEnd, tNode.data);

		tNode.left = buildTree(in, pre, inStrt, inIndex - 1);
		tNode.right = buildTree(in, pre, inIndex + 1, inEnd);

		return tNode;
	}
	
	private Node construct(int[] inorder, int[] preorder) {
		// create a map to efficiently find the index of any element in
		// given inorder sequence
		Map<Integer, Integer> map = new HashMap<>();
		for (int i = 0; i < inorder.length; i++) {
			map.put(inorder[i], i);
		}

		// pIndex stores index of next unprocessed node in preorder sequence
		// start with root node (present at 0'th index)
		AtomicInteger pIndex = new AtomicInteger(0);

		return construct(0, inorder.length - 1, preorder, pIndex, map);
	}
	
	// Recursive function to construct a binary tree from given
		// inorder and preorder sequence
		private Node construct(int start, int end,
									 int[] preorder, AtomicInteger pIndex,
									 Map<Integer, Integer> map) {
			// base case
			if (start > end) {
				return null;
			}

			// The next element in preorder[] will be the root node of subtree
			// formed by inorder[start, end]
			Node root = new Node(preorder[pIndex.getAndIncrement()]);

			// get the index of root node in inorder[] to determine the
			// boundary of left and right subtree
			int index = map.get(root.key);

			// recursively construct the left subtree
			root.left = construct(start, index - 1, preorder, pIndex, map);

			// recursively construct the right subtree
			root.right = construct(index + 1, end, preorder, pIndex, map);

			// return current node
			return root;
		}
}
